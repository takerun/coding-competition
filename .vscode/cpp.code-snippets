{
    "[Initialization] G++ Code": {
        "prefix": "g++",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define endl \"\\n\"",
            "#define endlif(cond) \" \\n\"[cond]",
            "typedef long long int int64;",
            "typedef unsigned long long int uint64;",
            "",
            "int main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    cout.tie(nullptr);",
            "    // input",
            "",
            "    // logic",
            "",
            "    // output",
            "",
            "    return 0;",
            "}",
        ],
    },
    "[Initialization] G++ Code boost": {
        "prefix": "g++_boost",
        "body": [
            "#pragma GCC optimize(\"unroll-loops\")",
            "#pragma GCC optimize(\"O3\")",
        ],
    },
    "[Include] modint998244353": {
        "prefix": "include_modint998244353",
        "body": [
            "#include <atcoder/modint>",
            "using mint = atcoder::modint998244353;"
        ],
    },
    "[Include] modint1000000007": {
        "prefix": "include_modint1000000007",
        "body": [
            "#include <atcoder/modint>",
            "using mint = atcoder::modint1000000007;"
        ],
    },
    "[Include] bit": {
        "prefix": "include_bit",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_ja/fenwicktree.html",
            "#include <atcoder/fenwicktree>",
            "using fenwick_tree = atcoder::fenwick_tree<int>;"
        ],
        "description": "include Binary-Indexed tree(Fenwick tree)"
    },
    "[Include] dsu": {
        "prefix": "include_dsu",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/dsu.html",
            "#include <atcoder/dsu>",
            "using dsu = atcoder::dsu;"
        ],
        "description": "include dsu(Union-Find tree)"
    },
    "[Include] segtree": {
        "prefix": "include_segtree",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/segtree.html",
            "#include <atcoder/segtree>",
            "using S = int64;                        // モノイドの型",
            "S op(S a, S b) { return max(a, b); }  // 取得演算: a+b, a*b, max(a,b)",
            "S e() { return 0; }                   // 単位元: 0, 1, -INF",
            "using segtree = atcoder::segtree<S, op, e>;",
            "// usage:",
            "// segtree seg(N);",
        ],
    },
    "[Include] lazy segtree": {
        "prefix": "include_lazy_segtree",
        "body": [
            "// https://atcoder.github.io/ac-library/document_en/lazysegtree.html",
            "// https://betrue12.hateblo.jp/entry/2020/09/23/005940",
            "#include <atcoder/lazysegtree>",
            "// 区間加算、区間最大値",
            "using S = int64;                           // モノイドの型",
            "S op(S a, S b) { return max(a, b); }       // 取得演算: max(a,b), min(a,b)",
            "S e() { return numeric_limits<S>::min(); }                  // 単位元: -INF, INF",
            "using F = int64;                           // 操作の型",
            "S mapping(F f, S x) { return f + x; }      // 操作演算:",
            "F composition(F f, F g) { return f + g; }  // 写像の合成:",
            "F id() { return 0; }                       // 恒等写像:",
            "using lazy_segtree =",
            "    atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;",
            "// usage pattern 1:",
            "// lazy_segtree seg(N);",
            "// usage pattern 2:",
            "// vector<S> v(N, {0, 1, 2});",
            "// lazy_segtree seg(v);",
            "",
            "// 区間加算、区間和取得",
            "// struct S {",
            "//     int64 value;",
            "//     int size;",
            "// };",
            "// using F = int64;",
            "// S op(S a, S b) { return {a.value + b.value, a.size + b.size}; }",
            "// S e() { return {0, 0}; }",
            "// S mapping(F f, S x) { return {x.value + f * x.size, x.size}; }",
            "// F composition(F f, F g) { return f + g; }",
            "// F id() { return 0; }",
            "// using lazy_segtree =",
            "//     atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;",
        ],
    },
    "[Include] chmin": {
        "prefix": "include_chmin",
        "body": [
            "template <class T>",
            "inline bool chmin(T& a, T b) {",
            "    if(a > b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
        ],
    },
    "[Include] chmax": {
        "prefix": "include_chmax",
        "body": [
            "template <class T>",
            "inline bool chmax(T& a, T b) {",
            "    if(a < b) {",
            "        a = b;",
            "        return true;",
            "    }",
            "    return false;",
            "}",
        ],
    },
    "[Include] power a ^ n": {
        "prefix": "include_pow",
        "body": "int64 pw(int64 a, int64 n) { return n == 0 ? 1LL : pw(a, n - 1) * a; }",
    },
    "[Include] floor of a / b": {
        "prefix": "include_floor",
        "body": [
            "template <class T>",
            "inline T floor_x_yth(T x, T y) {",
            "    // x/y: x(divident), y(divisor)",
            "    return x >= 0 ? (x / y) : -((-x + y - 1) / y);",
            "}",
        ],
    },
    "[Include] ceil of a / b": {
        "prefix": "include_ceil",
        "body": [
            "template <class T>",
            "inline T ceil_x_yth(T x, T y) {",
            "    // x/y: x(divident), y(divisor)",
            "    return x >= 0 ? ((x + y - 1) / y) : (x / y);",
            "}",
        ],
    },
    "[Def] 1d vector": {
        "prefix": "def_vec_1d",
        "body": "vector<int> A(N, 0);",
    },
    "[Def] 2d vector": {
        "prefix": "def_vec_2d",
        "body": "vector<vector<int>> Mat(H, vector<int>(W, 0));",
    },
    "[Def] Nd vector": {
        "prefix": "def_vec_Nd",
        "body": "vector State(I, vector(J, vector(K, vector(L, 0))));",
        "description": "define Nd vector with Template argument deduction"
    },
    "[Def] pair": {
        "prefix": "def_pair",
        "body": "pair<int, int> pr = {1, 10};",
    },
    "[Def] map": {
        "prefix": "def_map_1d",
        "body": "map<int, int> mp = {{1, 10}, {2, 20}};",
    },
    "[Def] priority_queue": {
        "prefix": "def_priority_queue",
        "body": [
            "priority_queue<int> q;  // max",
            "priority_queue<int, vector<int>, greater<int>> q;  // min",
        ],
    },
    "[Def] deque": {
        "prefix": "def_deque",
        "body": "deque<int> dq;",
    },
    "[Def] lambda function": {
        "prefix": "def_func",
        "body": [
            "auto func = [&](int a, int b) {",
            "    if(a <= b)",
            "        return b - a;",
            "    else",
            "        return a - b;",
            "};",
        ],
    },
    "[Def] lambda recursive function": {
        "prefix": "def_func_recursive",
        "body": [
            "auto func_rec = [&](auto &&self, int a) -> int {",
            "    if(a == 0)",
            "        return 0;",
            "    else",
            "        return self(self, a - 1) + a;",
            "};",
        ],
    },
    "[Input] 1 item": {
        "prefix": "cin_1",
        "body": [
            "int N;",
            "cin >> N;",
        ],
    },
    "[Input] 2 items": {
        "prefix": "cin_2",
        "body": [
            "int N, M;",
            "cin >> N >> M;",
        ],
    },
    "[Input] string": {
        "prefix": "cin_string",
        "body": [
            "string S;",
            "cin >> S;",
        ],
    },
    "[Input] 1d vector": {
        "prefix": "cin_vec_1d",
        "body": [
            "vector<int> A(N, 0);",
            "for(int i = 0; i < A.size(); i++) cin >> A[i];",
        ],
    },
    "[Input] 2d vector": {
        "prefix": "cin_vec_2d",
        "body": [
            "vector<vector<int>> Mat(H, vector<int>(W, 0));",
            "for(int i = 0; i < H; i++) {",
            "    for(int j = 0; j < W; j++) {",
            "        cin >> Mat[i][j];",
            "    }",
            "}",
        ],
    },
    "[Input] 1d vector with position": {
        "prefix": "cin_vec_1d_with_pos",
        "body": [
            "vector<int> A(N, 0), pos(N, 0);",
            "for(int i = 0; i < A.size(); i++) {",
            "    cin >> A[i];",
            "    pos[A[i]] = i;",
            "}",
        ],
    },
    "[Input] 1d vector with existence": {
        "prefix": "cin_vec_1d_with_exist",
        "body": [
            "vector<int> A(N, 0)",
            "vector<bool> exist(M, false);",
            "for(int i = 0; i < A.size(); i++) {",
            "    cin >> A[i];",
            "    exist[A[i]] = true;",
            "}",
            "// usage:",
            "// if(exist[a]) return;"
        ],
    },
    "[Input] graph": {
        "prefix": "cin_graph",
        "body": [
            "vector<vector<int>> graph(N);",
            "// vector<vector<int64>> weight(N);",
            "for(int i = 0; i < M; i++) {",
            "    int a, b;",
            "    cin >> a >> b, a--, b--;",
            "    graph[a].push_back(b);",
            "    // int64 w;",
            "    // cin >> w;",
            "    // weight[a].push_back(w);",
            "}",
        ],
    },
    "[Input] tree": {
        "prefix": "cin_tree",
        "body": [
            "vector<vector<int>> tree(N);",
            "// vector<vector<int64>> weight(N);",
            "for(int i = 0; i < M; i++) {",
            "    int a, b;",
            "    cin >> a >> b, a--, b--;",
            "    tree[a].push_back(b);",
            "    tree[b].push_back(a);",
            "    // int64 w;",
            "    // cin >> w;",
            "    // weight[a].push_back(w);",
            "    // weight[b].push_back(w);",
            "}",
        ],
    },
    "[Output] 1 item": {
        "prefix": "cout_1",
        "body": "cout << x << endl;",
    },
    "[Output] 2 items": {
        "prefix": "cout_2",
        "body": "cout << x << \" \" << y << endl;",
    },
    "[Output] double": {
        "prefix": "cout_double",
        "body": [
            "cout << fixed << setprecision(15);",
            "cout << x << endl;",
        ]
    },
    "[Output] 1d vector": {
        "prefix": "cout_vec_1d",
        "body": [
            "vector<int> A;",
            "for(int i = 0; i < A.size(); i++) cout << A[i] << endlif(i == A.size() - 1);",
        ],
    },
    "[Output] 2d vector": {
        "prefix": "cout_vec_2d",
        "body": [
            "vector<vector<int>> Mat;",
            "for(int i = 0; i < Mat.size(); i++)",
            "    for(int j = 0; j < Mat[i].size(); j++)",
            "        cout << Mat[i][j] << endlif(j == Mat[i].size() - 1);",
        ],
    },
    "[Output] yes no": {
        "prefix": "cout_yes_no",
        "body": "cout << (a ? \"Yes\" : \"No\") << endl;",
    },
    "[Convert] char to int": {
        "prefix": "to_int",
        "body": "int(C - '0');",
    },
    "[Convert] string to int": {
        "prefix": "to_int",
        "body": "stoi(S);",
    },
    "[Convert] toupper char": {
        "prefix": "to_upper",
        "body": "(char)toupper(c);",
    },
    "[Convert] tolower char": {
        "prefix": "to_lower",
        "body": "(char)tolower(c);",
    },
    "[Convert] toupper string": {
        "prefix": "to_upper",
        "body": [
            "for(int i = 0; i < S.size(); i++) S[i] = toupper(S[i]);"
        ],
    },
    "[Convert] tolower string": {
        "prefix": "to_lower",
        "body": [
            "for(int i = 0; i < S.size(); i++) S[i] = tolower(S[i]);"
        ],
    },
    "[Convert] substr string": {
        "prefix": "substr_string",
        "body": "S.substr(l, r - l); // [l, r)",
    },
    "[Convert] replace string": {
        "prefix": "replace_string",
        "body": "replace(begin(S), end(S), 'a', 'b');",
    },
    "[Convert] split string": {
        "prefix": "split_string",
        "body": [
            "// Sに空白が含まれると正常に動かないので注意",
            "string S;",
            "const string sep = \".\";",
            "auto offset = string::size_type(0);",
            "vector<string> splited;",
            "while(1) {",
            "    auto pos = S.find(sep, offset);",
            "    if(pos == string::npos) {",
            "        splited.push_back(S.substr(offset));",
            "        break;",
            "    }",
            "    splited.push_back(S.substr(offset, pos - offset));",
            "    offset = pos + sep.size();",
            "}",
        ],
    },
    "[Method] calculate remainder & quotient": {
        "prefix": "calc_remainder_quotient",
        "body": [
            "int r = (x % mod + mod) % mod;",
            "int q = (x - r) / mod;",
        ],
    },
    "[Method] calculate popcount": {
        "prefix": "calc_popcount",
        "body": "popcount((uint64)x);",
    },
    "[Method] calculate sum in 1d vector": {
        "prefix": "calc_sum_vec_1d",
        "body": "accumulate(begin(A), end(A), 0)",
    },
    "[Method] calculate sum in stack": {
        "prefix": "calc_sum_stack_1d",
        "body": [
            "int sum = 0;",
            "while(!stk.empty()) {",
            "    sum = sum + stk.top();",
            "    stk.pop();",
            "}",
        ],
    },
    "[Method] calculate manhattan distance": {
        "prefix": "calc_manhattan_distance",
        "body": [
            "int distance = 0;",
            "for(int i = 0; i < N; i++) distance += abs(A[i] - B[i]);",
        ],
    },
    "[Method] calculate volume of common volume of 2 cube": {
        "prefix": "calc_volume_2cube",
        "body": [
            "using T = int;",
            "auto volumeCube = [&](T blX1, T blY1, T blZ1, T trX1, T trY1, T trZ1,",
            "                        T blX2, T blY2, T blZ2, T trX2, T trY2, T trZ2) {",
            "    return max(0, min(trX1, trX2) - max(blX1, blX2)) *",
            "            max(0, min(trY1, trY2) - max(blY1, blY2)) *",
            "            max(0, min(trZ1, trZ2) - max(blZ1, blZ2));",
            "};",
        ],
        "description": "blはbottom left、trはtop rightの意味。3つの共通部分の体積を求めたい場合はmin({trX1,trX2,trX3})のように",
    },
    "[Method] equal in double": {
        "prefix": "is_equal_double",
        "body": [
            "double EPS = 1e-9;",
            "abs(x - y) <= EPS",
        ],
    },
    "[Method] equal to 1d vector": {
        "prefix": "is_equal_vec_1d",
        "body": "equal(begin(A), end(A), begin(B), end(B));",
    },
    "[Method] equal to 2d vector": {
        "prefix": "is_equal_vec_2d",
        "body": [
            "bool is_equal = true;",
            "for(int i = 0; i < N; i++) {",
            "    is_equal &= equal(begin(A), end(A), begin(B), end(B));",
            "}",
        ],
    },
    "[Method] is matched in regular expression": {
        "prefix": "is_matched_regex",
        "body": [
            "string S;",
            "regex_match(S, regex(\"A*B*C*\"))",
        ],
    },
    "[Method] is palindrome": {
        "prefix": "is_kaibun",
        "body": [
            "auto check = [&](int64 a) {",
            "    string s = to_string(a);",
            "    return s == string(rbegin(s), rend(s));",
            "    // bool flag = true;",
            "    // for(int i = 0; i < s.size(); i++) {",
            "    //     if(s[i] != s[s.size() - 1 - i]) flag = false;",
            "    // }",
            "    // return flag;",
            "};",
        ],
        "description": "回文を判定する"
    },
    "[Method] max value generally": {
        "prefix": "max_general",
        "body": [
            "int64 mx = numeric_limits<int64>::min();  // -9e18",
            "for(int i = 0; i < N; i++) chmax(mx, A[i]);",
        ],
    },
    "[Method] max value iterator in 1d vector": {
        "prefix": "max_vec_1d",
        "body": [
            "auto maxit = max_element(begin(v), end(v));",
            "// usage: *maxit, maxit - begin(v)",
        ],
    },
    "[Method] max value iterator in map": {
        "prefix": "max_map",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // valueが同値なら、keyの小さい要素を取得",
            "    if(left.second == right.second)",
            "        return left.first > right.first;",
            "    else  // valueが大きい要素を取得",
            "        return left.second < right.second;",
            "};",
            "auto maxit = max_element(begin(mp), end(mp), order);",
            "// usage: (*maxit).first, (*maxit).second, maxit++",
        ],
    },
    "[Method] max value iterator in set": {
        "prefix": "max_set",
        "body": [
            "auto maxit = --st.end();",
            "// usage: *maxit, maxit++",
        ],
    },
    "[Method] min value generally": {
        "prefix": "min_general",
        "body": [
            "int64 mn = numeric_limits<int64>::max();;  // 9e18",
            "for(int i = 0; i < N; i++) chmin(mn, A[i]);",
        ],
    },
    "[Method] min value iterator in 1d vector": {
        "prefix": "min_vec_1d",
        "body": [
            "auto minit = min_element(begin(v), end(v));",
            "// usage: *minit, minit - begin(v)",
        ],
    },
    "[Method] min value iterator in map": {
        "prefix": "min_map",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // valueが同値なら、keyの小さい要素を取得",
            "    if(left.second == right.second)",
            "        return left.first < right.first;",
            "    else  // valueが小さい要素を取得",
            "        return left.second < right.second;",
            "};",
            "auto minit = min_element(begin(mp), end(mp), order);",
            "// usage: (*minit).first, (*minit).second, minit++",
        ],
    },
    "[Method] min value iterator in set": {
        "prefix": "min_set",
        "body": [
            "auto minit = st.begin();",
            "// usage: *minit, minit++",
        ],
    },
    "[Method] find iterator in 1d vector": {
        "prefix": "find_vec_1d",
        "body": [
            "auto itr = find(begin(v), end(v), key);",
            "// usage: *itr, itr - begin(v), itr + n",
            "// itr == end(v) if not found",
        ],
    },
    "[Method] find slice at upper bound": {
        "prefix": "find_upper_bound_vec_1d",
        "body": [
            "auto uit = upper_bound(begin(v), end(v), key);",
            "// usage: *uit, uit - begin(v), uit + n",
        ],
    },
    "[Method] find slice at lower bound": {
        "prefix": "find_lower_bound_vec_1d",
        "body": [
            "auto lit = lower_bound(begin(v), end(v), key);",
            "// usage: *lit, lit - begin(v), lit + n",
        ],
    },
    "[Method] find slice at upper bound for pair vector": {
        "prefix": "find_upper_bound_vec_pair",
        "body": [
            "vector<pair<int, int>> v;",
            "auto first_order_ub = [](const auto &mid, const auto &pr) {",
            "    return mid < pr.first;",
            "};",
            "auto uit = upper_bound(begin(v), end(v), key, first_order_ub);",
            "// usage: *uit, uit - begin(v), uit + n",
        ],
    },
    "[Method] find slice at lower bound for pair vector": {
        "prefix": "find_lower_bound_vec_pair",
        "body": [
            "vector<pair<int, int>> v;",
            "auto first_order_lb = [](const auto &pr, const auto &mid) {",
            "    return pr.first < mid;",
            "};",
            "auto lit = lower_bound(begin(v), end(v), key, first_order_lb);",
            "// usage: *lit, lit - begin(v), lit + n",
        ],
    },
    "[Method] find slice iterator at upper bound for set": {
        "prefix": "find_upper_bound_set",
        "body": [
            "auto uit = st.upper_bound(key)",
            "// usage: *uit, uit++"
        ],
    },
    "[Method] find slice iterator at lower bound for set": {
        "prefix": "find_lower_bound_set",
        "body": [
            "auto lit = st.lower_bound(key)",
            "// usage: *lit, lit++"
        ],
    },
    "[Method] erase in 1d vector": {
        "prefix": "erase_vec_1d",
        "body": "v.erase(remove(begin(v), end(v), key), end(v));",
    },
    "[Method] erase in 1d vector using iterator": {
        "prefix": "erase_itr_vec_1d",
        "body": "v.erase(itr);",
    },
    "[Method] erase from to in 1d vector using iterator": {
        "prefix": "erase_from_to_vec_1d",
        "body": [
            "sort(begin(v), end(v));",
            "auto lit = lower_bound(begin(v), end(v), key_from),",
            "     uit = upper_bound(begin(v), end(v), key_to);",
            "v.erase(lit, uit);  // [from, to)",
        ],
    },
    "[Method] erase in map": {
        "prefix": "erase_map",
        "body": "mp.erase(key);",
    },
    "[Method] erase in map using iterator": {
        "prefix": "erase_itr_map",
        "body": "mp.erase(itr);",
    },
    "[Method] erase from to in map using iterator": {
        "prefix": "erase_from_to_map",
        "body": [
            "auto lit = mp.lower_bound(key_from), uit = mp.upper_bound(key_to);",
            "mp.erase(lit, uit);  // [from, to)",
        ],
    },
    "[Method] erase in set": {
        "prefix": "erase_set",
        "body": "st.erase(key);",
    },
    "[Method] erase in set using iterator": {
        "prefix": "erase_itr_set",
        "body": "st.erase(itr);",
    },
    "[Method] erase from to in set using iterator": {
        "prefix": "erase_from_to_set",
        "body": [
            "auto lit = st.lower_bound(key_from), uit = st.upper_bound(key_to);",
            "st.erase(lit, uit);  // [from, to)",
        ],
    },
    "[Method] erase duplicate in 1d vector": {
        "prefix": "erase_duplicate_vec_1d",
        "body": [
            "sort(begin(A), end(A));",
            "A.erase(unique(begin(A), end(A)), end(A));",
        ],
        "description": "重複をなくす"
    },
    "[Method] make cumulative in 1d vector": {
        "prefix": "cumul_vec_1d",
        "body": [
            "vector<int> A(N), cml(N + 1, 0);",
            "for(int i = 0; i < N; i++) cml[i + 1] = cml[i] + A[i];",
            "// usage:",
            "// cml[right] - cml[left]; // sum of [left, right)",
        ],
    },
    "[Method] make cumulative in 2d vector": {
        "prefix": "cumul_vec_2d",
        "body": [
            "vector mat(H, vector(W, 0LL));",
            "vector mcuml(H + 1, vector(W + 1, 0LL));",
            "for(int i = 0; i < H; i++) {",
            "    for(int j = 0; j < W; j++) {",
            "        // cin >> mat[i][j];",
            "        mcuml[i + 1][j + 1] =",
            "            mcuml[i + 1][j] + mcuml[i][j + 1] - mcuml[i][j] + mat[i][j];",
            "    }",
            "}",
            "// usage:",
            "// auto box_sum = [&](int l0, int r0, int l1, int r1) {",
            "//     return mcuml[r0][r1] - mcuml[r0][l1] - mcuml[l0][r1] + mcuml[l0][l1];",
            "// };",
            "// box_sum(lx, rx, ly, ry); // sum [lx, rx)",
        ],
    },
    "[Method] make cumulative in 3d vector": {
        "prefix": "cumul_vec_3d",
        "body": [
            "vector tens(N, vector(N, vector(N, 0LL)));",
            "vector tcuml(N + 1, vector(N + 1, vector(N + 1, 0LL)));",
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < N; j++) {",
            "        for(int k = 0; k < N; k++) {",
            "            // cin >> tens[i][j][k];",
            "            tcuml[i + 1][j + 1][k + 1] =",
            "                tcuml[i + 1][j + 1][k] + tcuml[i + 1][j][k + 1] +",
            "                tcuml[i][j + 1][k + 1] - tcuml[i + 1][j][k] -",
            "                tcuml[i][j + 1][k] - tcuml[i][j][k + 1] + tcuml[i][j][k] +",
            "                tens[i][j][k];",
            "        }",
            "    }",
            "}",
            "// usage:",
            "// auto cube_sum = [&](int l0, int r0, int l1, int r1, int l2, int r2) {",
            "//     return tcuml[r0][r1][r2] - tcuml[l0][r1][r2] - tcuml[r0][l1][r2] -",
            "//            tcuml[r0][r1][l2] + tcuml[l0][l1][r2] + tcuml[l0][r1][l2] +",
            "//            tcuml[r0][l1][l2] - tcuml[l0][l1][l2];",
            "// };",
            "// cube_sum(lx, rx, ly, ry, lz, rz); // sum [lx, rx)",
        ],
    },
    "[Method] make cumulative xor in 1d vector": {
        "prefix": "cumulx_vec_1d",
        "body": [
            "vector<int64> A(N), cumlx(N + 1, 0);",
            "for(int i = 0; i < N; i++) cumlx[i + 1] = cumlx[i] + (A[i] & (1 << d));",
            "// usage:",
            "// cumlx[right] ^ cumlx[left] * (1 << d) // xor-product [left, right)",
        ],
    },
    "[Method] make counter in 1d vector": {
        "prefix": "counter_vec_1d",
        "body": [
            "vector<int> A(N);",
            "map<int, int> ctr;",
            "for(int i = 0; i < N; i++) {",
            "    ctr[A[i]]++;",
            "}",
        ],
    },
    "[Method] count inversion num for 1d vector": {
        "prefix": "inversion_vec_1d",
        "body": [
            "// 転倒数を求めたい配列はA(0-indexed)とする。",
            "fenwick_tree bit(N);",
            "int64 inv = 0;",
            "for(int i = 0; i < N; i++) {",
            "    inv += i - bit.sum(0, A[i] + 1);",
            "    bit.add(A[i], 1);",
            "}",
            "// O(N^2)の求め方",
            "// int inv = 0;",
            "// for(int i = 0; i < N; i++)",
            "//     for(int j = 0; j < N; j++)",
            "//         if(i < j && A[i] > A[j]) inv++;",
        ],
    },
    "[Method] sort 1d vector ascending": {
        "prefix": "sort_vec_1d",
        "body": [
            "sort(begin(A), end(A));"
        ],
    },
    "[Method] sort 1d vector descending": {
        "prefix": "sort_vec_1d_desc",
        "body": [
            "sort(begin(A), end(A), greater<int>());"
        ],
    },
    "[Method] sort pair vector flexible order": {
        "prefix": "sort_vec_pair",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // 第一要素が同値なら、第二要素で降順",
            "    if(left.first == right.first)",
            "        return left.second > right.second;",
            "    else  // 第一要素で昇順",
            "        return left.first < right.first;",
            "};",
            "sort(begin(A), end(A), order);",
        ],
    },
    "[If] contain for 1d vector": {
        "prefix": "if_contain_vec_1d",
        "body": "if(count(begin(v), end(v), key))",
    },
    "[If] contain for string": {
        "prefix": "if_contain_string",
        "body": "if(count(begin(S), end(S), key_char))",
    },
    "[If] contain for map": {
        "prefix": "if_contain_map",
        "body": "if(mp.count(key))",
    },
    "[If] contain for set": {
        "prefix": "if_contain_set",
        "body": "if(st.count(key))",
    },
    "[If] Direction 4": {
        "prefix": "if_direction_4",
        "body": [
            "int nh = h, nw = w;",
            "if(d == 'R') {",
            "    nw++;",
            "} else if(d == 'L') {",
            "    nw--;",
            "} else if(d == 'U') {",
            "    nh--;",
            "} else {",
            "    nh++;",
            "}",
        ],
    },
    "[If] Direction 4 for xy": {
        "prefix": "if_direction_4xy",
        "body": [
            "int nx = x, ny = y;",
            "if(d == 'R') {",
            "    nx++;",
            "} else if(d == 'L') {",
            "    nx--;",
            "} else if(d == 'U') {",
            "    ny++;",
            "} else {",
            "    ny--;",
            "}",
        ],
    },
    "[If] outside of H * W": {
        "prefix": "if_outside_hw",
        "body": "if(nh < 0 or nh >= H or nw < 0 or nw >= W) continue;",
    },
    "[Frame] loop 1d": {
        "prefix": "loop_1d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop 2d": {
        "prefix": "loop_2d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < M; j++) {",
            "        // logic",
            "    }",
            "}"
        ],
    },
    "[Frame] loop 3d": {
        "prefix": "loop_3d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < M; j++) {",
            "        for(int k = 0; k < L; k++) {",
            "            // logic",
            "        }",
            "    }",
            "}",
        ],
    },
    "[Frame] loop Nd": {
        "prefix": "loop_Nd",
        "body": [
            "int N, depth;",
            "vector<int> items(depth, 0);",
            "auto loopN = [&](auto &&self, const int d) -> void {",
            "    // exit conditions",
            "    if(d == depth) {",
            "        // logic: use items",
            "        // for(int i = 0; i < items.size(); i++)",
            "        //     cout << items[i] << endlif(i == items.size() - 1);",
            "        return;",
            "    }",
            "",
            "    // loop i",
            "    for(int v = 0; v <= N; v++) {",
            "        items[d] = v;",
            "        self(self, d + 1);",
            "    }",
            "};",
            "// usage:",
            "// loopN(loopN, 0);",
        ],
    },
    "[Frame] loop 1d with logic": {
        "prefix": "loop_logic_1d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    if(i == 0) {",
            "        // init logic",
            "        continue;",
            "    }",
            "",
            "    // logic",
            "",
            "    if(i == N - 1) {",
            "        // last logic",
            "        continue;",
            "    }",
            "}",
        ],
    },
    "[Frame] loop digit": {
        "prefix": "loop_digit_2bit",
        "body": [
            "int64 x;",
            "for(int64 i = 0LL, num = x; num != 0LL; i++, num >>= 1LL) {",
            "    // logic",
            "    // int64 digit = 1LL << i;",
            "    // if(num & 1LL) {",
            "    //     cout << digit << endl;",
            "    // }",
            "}",
        ],
    },
    "[Frame] loop map": {
        "prefix": "loop_map",
        "body": [
            "map<int, int> mp;",
            "for(const auto &[key, val] : mp) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop set": {
        "prefix": "loop_set",
        "body": [
            "set<int> st;",
            "for(const auto &s : st) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop set from to": {
        "prefix": "loop_set_from_to",
        "body": [
            "set<int> st;",
            "auto lit = st.lower_bound(from), uit = st.upper_bound(to);",
            "for(; lit != uit; lit++) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop root N": {
        "prefix": "loop_root_n",
        "body": [
            "for(int64 i = 0; i * i <= N; i++) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop cycle": {
        "prefix": "loop_cycle",
        "body": [
            "int from, to, M;",
            "for(int i = from; i <= (from <= to ? to : to + M); i++) {",
            "    int ii = i % M;",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop direction 4": {
        "prefix": "loop_direction_4",
        "body": [
            "for(int r = 0; r < 4; r++) {",
            "    auto [nh, nw] = D4.next(h, w, r);",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop direction 4 for xy": {
        "prefix": "loop_direction_4xy",
        "body": [
            "for(int r = 0; r < 4; r++) {",
            "    auto [nx, ny] = D4.next(x, y, r);",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop A-Z": {
        "prefix": "loop_A-Z",
        "body": [
            "for(char c = 'A'; c <= 'Z'; c++) {",
            "    // logic",
            "}",
        ],
    },
    "[Frame] loop Permutation": {
        "prefix": "loop_permitation",
        "body": [
            "// N!",
            "vector<int> P;",
            "for(int i = 0; i < N; i++) P.emplace_back(i);",
            "do {",
            "    // logic: use P",
            "    // for(int i = 0; i < P.size(); i++)",
            "    //     cout << P[i] << endlif(i == P.size() - 1);",
            "} while(next_permutation(begin(P), end(P)));"
        ],
    },
    "[Frame] loop Combination no duplicate": {
        "prefix": "loop_combination_no_duplicate",
        "body": [
            "// nCr, r: ball, n: box, n >= r",
            "int N, R;",
            "vector<int> combi(R, 0);",
            "auto loop_cmb_nodup = [&](auto &&self, const int d, const int st) -> void {",
            "    // exit conditions",
            "    if(d == R) {",
            "        // logic: use combi",
            "        // for(int i = 0; i < combi.size(); i++)",
            "        //     cout << combi[i] << endlif(i == combi.size() - 1);",
            "        return;",
            "    }",
            "",
            "    // loop i",
            "    for(int v = st + 1; v < N; v++) {",
            "        combi[d] = v;",
            "        self(self, d + 1, v);",
            "    }",
            "};",
            "// usage:",
            "// loop_cmb_nodup(loop_cmb_nodup, 0, -1);",
        ],
    },
    "[Frame] loop Combination duplicate": {
        "prefix": "loop_combination_duplicate",
        "body": [
            "// n+r-1Cn, n: ball, r: box",
            "int N, R;",
            "vector<int> combi(N, 0), ball_num(R, 0);",
            "auto loop_cmb_dup = [&](auto &&self, const int d, const int st) -> void {",
            "    // exit conditions",
            "    if(d == N) {",
            "        // logic: use combi",
            "        // for(int i = 0; i < combi.size(); i++)",
            "        //     cout << combi[i] << endlif(i == combi.size() - 1);",
            "        // logic: use ball_num",
            "        // for(int i = 0; i < ball_num.size(); i++)",
            "        //     cout << ball_num[i] << endlif(i == ball_num.size() - 1);",
            "        return;",
            "    }",
            "",
            "    // loop i",
            "    for(int v = st; v < R; v++) {",
            "        combi[d] = v;",
            "        ball_num[v]++;",
            "        self(self, d + 1, v);",
            "        ball_num[v]--;",
            "    }",
            "};",
            "// usage:",
            "// loop_cmb_dup(loop_cmb_dup, 0, 0);",
        ],
    },
    "[Frame] loop bit full search": {
        "prefix": "loop_bit_full_search",
        "body": [
            "int Nbit = 5;",
            "vector<int> bit(Nbit);",
            "// 3進数の場合: for(int i = 0; i < int(pow(3, Nbit)); i++) ※powの誤差に注意",
            "for(int i = 0; i < (1 << Nbit); i++) {",
            "    int pow = 1;",
            "    for(int digit = 0; digit < Nbit; digit++)",
            "        // 3進数の場合: bit[digit] = (i / pow) % 3, pow *= 3;",
            "        bit[digit] = (i / pow) % 2, pow <<= 1;",
            "    // logic: use bit",
            "    // for(int i = 0; i < bit.size(); i++)",
            "    //     cout << bit[i] << endlif(i == bit.size() - 1);",
            "}",
        ],
    },
    "[Algorithm] compress coordinate in 1d vector": {
        "prefix": "compress_coordinate_vec_1d",
        "body": [
            "vector<int> A = {8, 100, 33, 33, 33, 12, 6, 1211};",
            "vector<int> B = A; ",
            "sort(begin(B), end(B));",
            "B.erase(unique(begin(B), end(B)), end(B));",
            "// usage:",
            "// lower_bound(begin(B), end(B), keyA) - begin(B);",
        ],
        "description": "座標圧縮、配列の中で何番目に小さいかを求める",
    },
    "[Algorithm] compress run length in 1d vector": {
        "prefix": "compress_runlength_vec_1d",
        "body": [
            "int ans = 0;",
            "int pre = 0;",
            "for (int i = 1; i < N; i++) {",
            "    if (A[i] != A[i - 1]) {",
            "        ans += f(i - pre);",
            "        pre = i;",
            "    }",
            "}",
            "ans += f(N - pre);",
        ],
        "description": "ランレングス圧縮、配列の中で同じ値が連続する区間に対し評価値を与える",
    },
    "[Algorithm] doubling": {
        "prefix": "doubling",
        "body": [
            "int N;",
            "int64 K;  // transform count",
            "int MAX_DOUBLING = 64;",
            "vector<vector<int>> next(MAX_DOUBLING, vector<int>(N));",
            "for(int i = 0; i < N; i++) cin >> next[0][i], next[0][i]--;  // input",
            "for(int d = 0; d + 1 < MAX_DOUBLING; d++) {",
            "    for(int i = 0; i < N; i++) {",
            "        next[d + 1][i] = next[d][next[d][i]];",
            "    }",
            "}",
            "int transformed_i = i;",
            "for(int d = 0; d < MAX_DOUBLING; ++d) {",
            "    if(K & (1LL << d)) transformed_i = next[d][transformed_i];",
            "}",
        ],
    },
    "[Algorithm] binary search": {
        "prefix": "binary_search",
        "body": [
            "auto f = [&](int64 x) { return x >= K; };  // 判定問題",
            "int64 ng = -1, ok = 2e18;  // ng:解が存在しない値, ok:解が存在する値",
            "// int64 ng = 2e18, ok = 0;  // 反転も可能",
            "while(abs(ok - ng) > 1) {",
            "    int64 mid = (ok + ng) / 2;",
            "    if(f(mid))",
            "        ok = mid;",
            "    else",
            "        ng = mid;",
            "}",
        ],
        "description": "binary search for a function",
    },
    "[Algorithm] general dfs": {
        "prefix": "dfs",
        "body": [
            "map<int, int> m;",
            "auto dfs = [&](auto &&self, const int64 x) -> int64 {",
            "    // exit conditions",
            "    if(x == 0) return 0;",
            "",
            "    // shortcut conditions",
            "",
            "    // use memo",
            "    if(m.count(x)) return m[x];",
            "",
            "    // try all moves",
            "    // pattern1:",
            "    // return m[x] = self(self, x1) + self(self, x2) + x;",
            "",
            "    // pattern2:",
            "    // for(int v = 0; v < N; v++) {",
            "    //     Stat.push_back(v);",
            "    //     self(self, x + 1);",
            "    //     Stat.pop_back();",
            "    // }",
            "",
            "    // pattern3:",
            "    // if(self(self, x1)) return true;",
            "    // if(self(self, x2)) return true;",
            "    // return false",
            "};",
            "// usage:",
            "// dfs(dfs, 100);",
        ],
    },
    "[Algorithm] graph dfs": {
        "prefix": "dfs_graph",
        "body": [
            "// outer variable: vector<vector<int>> graph",
            "vector<bool> seen(N, false), finished(N, false);",
            "vector<int64> score_subgraph(N, 0LL);",
            "auto dfs_graph = [&](auto &&self, const int node) -> int64 {",
            "    // shortcut",
            "",
            "    // inflow logic",
            "    seen[node] = true;",
            "    for(int i = 0; i < graph[node].size(); i++) {",
            "        int chi = graph[node][i];",
            "        if(seen[chi]) continue; // if(finished[node])",
            "        self(self, chi);",
            "    }",
            "    // shortcut",
            "",
            "    // outflow logic",
            "    finished[node] = true;",
            "    return 0LL;",
            "};",
            "// usage:",
            "// for (int i = 0; i < N; ++i) {",
            "//     if (seen[i]) continue;",
            "//     dfs_graph(dfs_graph, i)",
            "// }",
        ],
    },
    "[Algorithm] tree dfs": {
        "prefix": "dfs_tree",
        "body": [
            "// ロジックは、葉-枝-根の順に確かめる",
            "vector<vector<int>> tree",
            "vector<int64> score_subtree(N, 0LL);",
            "auto dfs_tree = [&](auto &&self, const int node, const int par) -> int64 {",
            "    // shortcut",
            "",
            "    // inflow logic",
            "",
            "    for(int i = 0; i < tree[node].size(); i++) {",
            "        int chi = tree[node][i];",
            "        if(chi == par) continue;",
            "        self(self, chi, node);",
            "        // faster outflow logic",
            "",
            "    }",
            "",
            "    // outflow logic",
            "    score_subtree[node] = basic_score;",
            "    for(int i = 0; i < tree[node].size(); i++) {",
            "        int chi = tree[node][i];",
            "        if(chi == par) continue;",
            "        score_subtree[node] += score_subtree[chi];",
            "    }",
            "    // int64 score_partree = socre_wholetree - score_subtree[node];",
            "    return 0LL;",
            "};",
            "// usage:",
            "// dfs_tree(dfs_tree, 0, -1);",
        ],
    },
    "[Algorithm] game dfs": {
        "prefix": "dfs_game",
        "body": [
            "// optional: WinCase wincase, WinCase wincase_opponent",
            "// tips: state watches the rest of moves, wincase records the effects of past moves",
            "// return the score difference of the best move in the given state",
            "auto dfs_game = [&](auto&& self, const WinCase wincase,",
            "                    const WinCase wincase_opponent,",
            "                    const State state) -> ScoreDiff {",
            "    // shortcut conditions",
            "    if(wincase_opponent == is_win) return -win_score;",
            "",
            "    // exit conditions",
            "    if(state == is_end) return score_in_end;",
            "",
            "    // use memo",
            "",
            "    // try all moves, select the best one",
            "    int res = numeric_limits<int>::min();",
            "    for(next_s : all_of_next_state) {",
            "        update(wincase);",
            "        // self(self, wincase_opponent, wincase, next_s) return a score",
            "        // from opponent's view",
            "        res = max(res, score_of_move -",
            "                            self(self, wincase_opponent, wincase, next_s));",
            "    }",
            "    return res;",
            "};",
            "// usage:",
            "// dfs_game(dfs_game, WinCase, WinCase, State);  // A - B",
            "// (dfs_game(dfs_game, WinCase, WinCase, State) + sum) / 2;  // A's score",
            "// (sum - dfs_game(dfs_game, WinCase, WinCase, State)) / 2;  // B's score",
        ],
    },
    "[Algorithm] game dfs another": {
        "prefix": "dfs_game_another",
        "body": [
            "// outer variable: State state, map<state, ScoreDiff> dp",
            "// tips: state watches all of moves; past and next",
            "// return the score difference of the best move in the given state",
            "auto dfs_game = [&](auto&& self, const int turn) -> ScoreDiff {",
            "    // shortcut conditions, when lose",
            "    if(isWin(turn ^ 1)) return -winScore;",
            "",
            "    // exit conditions",
            "    if(isEnd()) return 0;",
            "",
            "    // use memo",
            "    if(dp.count(state)) return dp[state];",
            "",
            "    // try all moves, select the best one",
            "    int res = numeric_limits<int>::min();",
            "    for(next_s : all_of_next_state) {",
            "        if(state[i][j] != -1) continue;",
            "        // self(self, turn ^ 1) return a score from opponent's view",
            "        state[i][j] = turn;",
            "        res = max(res, score_of_move - self(self, turn ^ 1));",
            "        state[i][j] = -1;",
            "    }",
            "    return dp[state] = res;",
            "};",
            "// usage:",
            "// dfs_game(dfs_game, 0);  // A - B",
            "// (dfs_game(dfs_game, 0) + sum) / 2;  // A's score",
            "// (sum - dfs_game(dfs_game, 0)) / 2;  // B's score",
        ],
    },
    "[Algorithm] cycle dfs": {
        "prefix": "dfs_cycle",
        "body": [
            "// outer variable: vector<vector<int>> graph",
            "int found_node = -1;",
            "vector<bool> seen(N, false), finished(N, false);",
            "stack<int> history;",
            "auto dfs_graph = [&](auto &&self, const int node) -> void {",
            "    // shortcut",
            "    if(found_node != -1) return;",
            "    // inflow logic",
            "    if(seen[node] and !finished[node]) {",
            "        found_node = node;",
            "        return;",
            "    }",
            "    seen[node] = true;",
            "    history.push(node);",
            "    for(int i = 0; i < graph[node].size(); i++) {",
            "        int chi = graph[node][i];",
            "        if(finished[chi]) continue;",
            "        self(self, chi);",
            "    }",
            "    // outflow logic",
            "    if(found_node != -1) return;",
            "    finished[node] = true;",
            "    history.pop();",
            "};",
            "",
            "for(int i = 0; i < N; i++) {",
            "    if(found_node != -1) break;",
            "    if(finished[i]) continue;",
            "    dfs_graph(dfs_graph, i);",
            "}",
            "vector<int> res;",
            "while(!history.empty()) {",
            "    int v = history.top();",
            "    history.pop();",
            "    res.push_back(v);",
            "    if(v == found_node) break;",
            "}",
            "reverse(begin(res), end(res));",
        ],
    },
    "[Algorithm] bfs": {
        "prefix": "bfs",
        "body": [
            "int H, W;",
            "// define seen and score",
            "vector<vector<bool>> seen(H, vector<bool>(W, false));  // or int to color grids",
            "vector<vector<int>> score(H, vector<int>(W, numeric_limits<int>::max()));",
            "// define queue",
            "using Qsv = tuple<int, int, int>;  // h, w, score",
            "queue<Qsv> Q;  // priority_queue<Qsv, vector<Qsv>, greater<Qsv>> Q;",
            "Q.push({0, 0, -1});",
            "while(!Q.empty()) {",
            "    // pop queue",
            "    auto [h, w, s] = Q.front();  // Q.top();",
            "    Q.pop();",
            "",
            "    // skip seen state",
            "    if(seen[h][w]) continue;",
            "",
            "    // seeing logic",
            "    seen[h][w] = true;",
            "    chmin(score[h][w], s + 1);",
            "",
            "    // push queue",
            "    for(int r = 0; r < 4; r++) {",
            "        auto [nh, nw] = D4.next(h, w, r);  // next state",
            "        // skip state",
            "        if(nh < 0 or nh >= H or nw < 0 or nw >= W) continue;",
            "        if(seen[nh][nw]) continue;",
            "        // push state",
            "        Q.emplace(nh, nw, score[h][w]);",
            "    }",
            "}",
        ],
    },
    "[Algorithm] imos": {
        "prefix": "imos",
        "body": [
            "// count",
            "vector<int64> imos(T + 1, 0);",
            "for(int i = 0; i < N; i++) {",
            "    imos[from] += num;",
            "    imos[to] -= num;",
            "}",
            "// simulate",
            "int64 cuml = imos[0];",
            "int64 mn = cuml;",
            "for(int i = 1; i < T; i++) {",
            "    // i=Tまで累積和を計算すると、注目する期間に加え1秒後の状態0を含む期間となる",
            "    // 1秒後の状態0は大概不要",
            "    cuml += imos[i];",
            "    mn = min(mn, cuml);",
            "}",
            "cout << mn << endl;",
        ],
    },
    "[Algorithm] general DP": {
        "prefix": "dp_general",
        "body": [
            "// initialize dp",
            "vector<int64> dp(N, 0LL);",
            "",
            "// init sub score",
            "dp[0] = 1;",
            "",
            "// update dp",
            "for(int i = 1; i < N; i++) {",
            "    // logic",
            "    // dp[i] = max(dp[i - 1], dp[i - 1] + a);",
            "}",
        ],
    },
    "[Algorithm] 0-1knapsack DP": {
        "prefix": "dp_knapsack_01",
        "body": [
            "// outer variable: int N, W, vector<int> w(N, 0), v(N, 0)",
            "vector<int> dp(W + 1, 0);",
            "for(int i = 0; i < N; i++) {",
            "    for(int j = W; j >= 0; j--) {",
            "        if(j - w[i] < 0) continue;",
            "        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);",
            "    }",
            "}",
            "// usage:",
            "// dp[W];",
        ],
        "description": "0-1でなく、個数制限なしの場合はjのループを0~Wのj++方向で回す。"
    },
    "[Algorithm] digit DP": {
        "prefix": "dp_digit",
        "body": [
            "string Ns;",
            "// pattern of N = 063435:",
            "// 00000-59999, 60000-62999, 63000-63399, 63400-63429, 63430-63434, 63435",
            "// digit * is_smaller(0-9 available) * sum_digit",
            "int D = Ns.size(), F = 2, I = D * 10;",
            "vector dp(D + 1, vector(F, vector(I, 0LL)));  // value: count",
            "dp[0][0][0] = 1LL;  // seed for sum",
            "for(int d = 0; d < D; d++) {",
            "    int Nd = int(Ns[d] - '0');",
            "    for(int f = 0; f < F; f++) {",
            "        for(int i = 0; i < I; i++) {",
            "            // smaller -> smaller",
            "            // for(int nx = 0; nx < 10; nx++) {",
            "            //     if(i + nx >= I) continue;",
            "            //     dp[d + 1][1][i + nx] += dp[d][1][i];",
            "            // }",
            "            // exact -> smaller",
            "            // for(int nx = 0; nx < Nd; nx++) {",
            "            //     if(i + nx >= I) continue;",
            "            //     dp[d + 1][1][i + nx] += dp[d][0][i];",
            "            // }",
            "            // exact -> exact",
            "            // if(i + Nd >= I) continue;",
            "            // dp[d + 1][0][i + Nd] += dp[d][0][i];",
            "",
            "            // way to put the above together",
            "            for(int nx = 0; nx < 10; nx++) {",
            "                if(not(f or (nx <= Nd))) continue;",
            "                int nf = f or (nx < Nd);",
            "                // update dp",
            "                int ni = i + nx;  // sum_digit",
            "                if(ni >= I) continue;",
            "                dp[d + 1][nf][ni] += dp[d][f][i];",
            "            }",
            "        }",
            "    }",
            "}",
            "// usage",
            "// dp[D][1][i] + dp[D][0][i];  // N=0を数え上げない時は-1する",
        ],
        "description": "桁DP"
    },
    "[Algorithm] digit DP with leading zero": {
        "prefix": "dp_digit_leading_zero",
        "body": [
            "string Ns;",
            "// pattern of N = 063435:",
            "// 00000-59999, 60000-62999, 63000-63399, 63400-63429, 63430-63434, 63435",
            "// digit * is_smaller(0-9 available) * get_out_of_leading_zero * prod_digit",
            "int D = Ns.size(), F = 2, Lz = 2, I = pw(9, D) + 1;",
            "vector dp(D + 1, vector(F, vector(Lz, vector(I, 0LL))));  // value: count",
            "// seeds for prod, not allowed to update dp[*][*][0][*]",
            "dp[0][0][0][1] = 1LL;",
            "for(int d = 1; d < D; d++) dp[d][1][0][1] = 1LL;  // for 0****, 00***, ...",
            "// digit dp",
            "for(int d = 0; d < D; d++) {",
            "    int Nd = int(Ns[d] - '0');",
            "    for(int f = 0; f < F; f++) {",
            "        for(int lz = 0; lz < Lz; lz++) {",
            "            for(int i = 0; i < I; i++) {",
            "                for(int nx = 0; nx < 10; nx++) {",
            "                    // smaller -> smaller, exact -> smaller, exact -> exact",
            "                    if(not(f or (nx <= Nd))) continue;",
            "                    int nf = f || (nx < Nd);",
            "                    // get out of leading zero,",
            "                    // not allowed to update dp[*][*][0][*]",
            "                    int nlz = lz || nx > 0;",
            "                    if(not nlz) continue;",
            "                    // update dp",
            "                    int64 ni = i * nx;  // prod_digit",
            "                    if(ni >= I) continue;",
            "                    dp[d + 1][nf][nlz][ni] += dp[d][f][lz][i];",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            "// usage",
            "// dp[D][1][1][i] + dp[D][0][1][i];  // N=0を数え上げる時は+1する",
        ],
    },
    "[Algorithm] rerouting tree DP": {
        "prefix": "dp_rerouting",
        "body": [
            "// https://ei1333.hateblo.jp/entry/2017/04/10/224413",
            "// outer variable: vector<vector<int>> tree, vector<int64> Dsubtree",
            "int root_ver = 0;",
            "vector<int64> score(N, 0LL);",
            "auto rerouting = [&](auto &&self, const int ver, const int par,",
            "                     const int64 Dpar) -> void {",
            "    // solve ver's score",
            "    score[ver] = Dsubtree[ver] + Dpar;",
            "    for(int i = 0; i < tree[ver].size(); i++) {",
            "        int ver_sub = tree[ver][i];",
            "        if(ver_sub == par) continue;",
            "        // prepare next Dpar from ver_sub's side",
            "        // int64 Dpar_sub = score[ver] - Dsubtree[ver_sub];",
            "        // solve ver_sub's socre",
            "        self(self, ver_sub, ver, Dpar_sub);",
            "    }",
            "};",
            "// usage:",
            "// ルートノードには親サイドが存在しないので、Dparは0",
            "// rerouting(rerouting, root_ver, -1, 0);",
            "// *max_element(begin(score), end(score));",
        ],
        "description": "全方位木DP"
    },
    "[Algorithm] Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "constexpr int64 INF = (1LL << 60);",
            "struct Edge {",
            "    int to;",
            "    int64 cost;",
            "};",
            "using Graph = vector<vector<Edge>>;",
            "using Pair = pair<int64, int>;  // {distance, from}",
            "",
            "// ダイクストラ法:",
            "// 負の閉路がなければ実行可能",
            "// distances は頂点数と同じサイズ, 全要素 INF で初期化しておく",
            "// Graph G(V);",
            "//   G[from].emplace_back(to, cost);",
            "// vector<int64> d(V, INF);",
            "// Dijkstra(G, d, 0);",
            "// cout << d[V - 1];",
            "void Dijkstra(const Graph& graph, vector<int64>& distances,",
            "              int startIndex) {",
            "    // 「現時点での最短距離, 頂点」の順に取り出す priority_queue",
            "    // デフォルトの priority_queue は降順に取り出すため greater を使う",
            "    priority_queue<Pair, vector<Pair>, greater<Pair>> q;",
            "    q.emplace((distances[startIndex] = 0), startIndex);",
            "",
            "    while(!q.empty()) {",
            "        const int64 distance = q.top().first;",
            "        const int from = q.top().second;",
            "        q.pop();",
            "",
            "        // 最短距離でなければ処理しない",
            "        if(distances[from] < distance) {",
            "            continue;",
            "        }",
            "",
            "        // 現在の頂点からの各辺について",
            "        for(const auto& edge : graph[from]) {",
            "            // 連結がなければスキップする",
            "",
            "            // to までの新しい距離",
            "            const int64 d = (distances[from] + edge.cost);",
            "",
            "            // d が現在の記録より小さければ更新",
            "            if(d < distances[edge.to]) {",
            "                q.emplace((distances[edge.to] = d), edge.to);",
            "            }",
            "        }",
            "    }",
            "}",
        ],
    },
    "[Method] two pointers": {
        "prefix": "two_pointers",
        "body": [
            "int64 val = 0;",
            "int left = 0, right = 0;",
            "while(left < N) {",
            "    // optional: keep left < right",
            "    while(left >= right) right++;",
            "    if(right >= N) break;",
            "",
            "    // slide right pos",
            "    int next_right = right;",
            "    while(++next_right < N and condition_lr_span)",
            "        right = next_right;",
            "",
            "    // calc value",
            "    int64 length = (right - left);",
            "    val += f(length);",
            "",
            "    // next left pos",
            "    left = right;",
            "    //left++;",
            "",
            "    // end condition",
            "    if(left == N - 1) break;",
            "}",
        ],
        "description": "しゃくとり法",
    },
    "[Data] Binominal": {
        "prefix": "data_binominal",
        "body": [
            "struct Binomial {",
            "    // fac: n!, invfac: 1 / n!",
            "    vector<mint> fac, invfac, inv;",
            "    Binomial(int n) : fac(n + 1), invfac(n + 1), inv(n + 1) {",
            "        fac[0] = invfac[0] = inv[0] = 1;",
            "        for(int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i;",
            "        invfac[n] = fac[n].inv();",
            "        for(int i = n - 1; i >= 0; i--) {",
            "            invfac[i] = invfac[i + 1] * (i + 1);",
            "            inv[i + 1] = invfac[i + 1] * fac[i];",
            "        }",
            "    }",
            "} Bi{303030};",
            "mint nCr(int n, int r) {",
            "    if(n < r) return 0;",
            "    if(n < 0 or r < 0) return 0;",
            "    return Bi.fac[n] * Bi.invfac[r] * Bi.invfac[n - r];",
            "}",
        ]
    },
    "[Data] prime numbers": {
        "prefix": "data_prime_number",
        "body": [
            "struct Eratos {",
            "    vector<bool> isprime;",
            "    vector<int64> primes;",
            "    Eratos(int n) {",
            "        isprime.resize(n, true);",
            "        isprime[0] = false;",
            "        isprime[1] = false;",
            "        for(int64 i = 2; i < n; ++i) isprime[i] = true;",
            "        for(int64 i = 2; i < n; ++i) {",
            "            if(isprime[i]) {",
            "                primes.push_back(i);",
            "                for(int64 j = i * 2; j < n; j += i) isprime[j] = false;",
            "            }",
            "        }",
            "    }",
            "} Er{1000005};",
        ]
    },
    "[Data] Direction 4": {
        "prefix": "data_direction_4",
        "body": [
            "struct Direction4 {",
            "    using D4type = int;                                         // or int64",
            "    const D4type dh[4] = {1, 0, 0, -1}, dw[4] = {0, -1, 1, 0};  // DLRU",
            "    const int rotation[4] = {2, 1, 3, 0};                       // RLUD",
            "    pair<D4type, D4type> next(D4type h, D4type w, int r) {",
            "        return {h + dh[rotation[r]], w + dw[rotation[r]]};",
            "    }",
            "    pair<D4type, D4type> next(D4type h, D4type w, char d) {",
            "        int nh = h, nw = w;",
            "        if(d == 'R') {",
            "            nw++;",
            "        } else if(d == 'L') {",
            "            nw--;",
            "        } else if(d == 'U') {",
            "            nh--;",
            "        } else {",
            "            nh++;",
            "        }",
            "        return {nh, nw};",
            "    }",
            "} D4;",
            "// usage:",
            "// auto [nh, nw] = D4.next(h, w, 0);",
            "// auto [nh, nw] = D4.next(h, w, 'R');",
        ]
    },
    "[Data] Direction 4 for xy": {
        "prefix": "data_direction_4xy",
        "body": [
            "struct Direction4 {",
            "    using D4type = int;                                         // or int64",
            "    const D4type dx[4] = {0, -1, 1, 0}, dy[4] = {-1, 0, 0, 1};  // DLRU",
            "    const int rotation[4] = {2, 1, 3, 0};                       // RLUD",
            "    pair<D4type, D4type> next(D4type x, D4type y, int r) {",
            "        return {x + dx[rotation[r]], y + dy[rotation[r]]};",
            "    }",
            "    pair<D4type, D4type> next(D4type x, D4type y, char d) {",
            "        int nx = x, ny = y;",
            "        if(d == 'R') {",
            "            nx++;",
            "        } else if(d == 'L') {",
            "            nx--;",
            "        } else if(d == 'U') {",
            "            ny++;",
            "        } else {",
            "            ny--;",
            "        }",
            "        return {nx, ny};",
            "    }",
            "} D4;",
            "// usage:",
            "// auto [nx, ny] = D4.next(x, y, 0);",
            "// auto [nx, ny] = D4.next(x, y, 'R');",
        ]
    },
}
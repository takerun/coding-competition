{
    "[Initialization] G++ Code": {
        "prefix": "g++",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fastIO() ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)",
            "#define endl \"\\n\"",
            "typedef long long int int64;",
            "",
            "int main()",
            "{",
            "    fastIO();",
            "    // input",
            "",
            "    // logic",
            "",
            "    // output",
            "    cout << endl;",
            "    return 0;",
            "}"
        ],
        "description": "G++ Code Setup"
    },
    "[Include] modint998244353": {
        "prefix": "include_modint998244353",
        "body": [
            "#include<atcoder/modint>",
            "using mint=atcoder::modint998244353;"
        ],
        "description": "include modint998244353"
    },
    "[Include] modint1000000007": {
        "prefix": "include_modint1000000007",
        "body": [
            "#include<atcoder/modint>",
            "using mint=atcoder::modint1000000007;"
        ],
        "description": "include modint1000000007"
    },
    "[Def] 1d vector": {
        "prefix": "def_vector_1d",
        "body": "vector<int> x(N, 0);",
        "description": "define 1d vector"
    },
    "[Def] 2d vector": {
        "prefix": "def_vector_2d",
        "body": "vector<vector<int>> X(N, vector<int>(M, 0));",
        "description": "define 2d vector"
    },
    "[Input] each string": {
        "prefix": "input_string_with_vec_int",
        "body": [
            "string S;",
            "cin >> S;",
            "vector<int> a;",
            "for (int i = 0; i < S.size(); i++)",
            "{",
            "    a.emplace_back(S[i] - '0');",
            "}",
        ],
        "description": "each sting input"
    },
    "[Measure] manhattan distance": {
        "prefix": "measure_manhattan_distance",
        "body": [
            "int distance = 0;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    distance += abs(x[i] - y[i]);",
            "}",
        ],
        "description": "manhattan distance"
    },
    "[Method] compare 1d vector": {
        "prefix": "equal_vec_1d",
        "body": "equal(begin(A), end(A), begin(B), end(B));",
        "description": "compare 1d vactor"
    },
    "[Method] compare 2d vector": {
        "prefix": "equal_vec_2d",
        "body": [
            "bool ans = true;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    ans &= equal(begin(A), end(A), begin(B), end(B));",
            "}",
        ]
        "description": "compare 2d vactor"
    },
    "[Method] retrieving max in 1d vector": {
        "prefix": "max_vec_1d",
        "body": "*max_element(begin(x), end(x))",
        "description": "max in 1d vactor"
    },
    "[Method] retrieving min in 1d vector": {
        "prefix": "min_vec_1d",
        "body": "*min_element(begin(x), end(x))",
        "description": "min in 1d vactor"
    },
    "[Method] retrieving sum in 1d vector": {
        "prefix": "sum_vec_1d",
        "body": "accumulate(begin(x), end(x), 0)",
        "description": "sum in 1d vactor"
    },
    "[Method] retrieving sum in stack": {
        "prefix": "sum_stack_1d",
        "body": [
            "int sum = 0;",
            "while (!s.empty())",
            "{",
            "    sum = sum + s.top();",
            "    s.pop();",
            "}",
        ],
        "description": "sum in 1d stack"
    },
    "[Method] retrieving cumulative in 1d vector": {
        "prefix": "cumul_vec_1d",
        "body": [
            "vector<int> x(N), cuml(N+1);",
            "cuml[0] = 0;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    cuml[i + 1] = cuml[i] + x[i];",
            "}"
        ],
        "description": "1d cumulative input"
    },
    "[Method] not being duplicate in 1d vector": {
        "prefix": "no_duplicate_vec_1d",
        "body": [
            "sort(begin(x), end(x));",
            "x.erase(unique(begin(x), end(x)), end(x));",
        ],
        "description": "no duplicate for 1d vec"
    },
    "[Method] inversion num for 1d vector": {
        "prefix": "inversion_vec_1d",
        "body": [
            "// 転倒数を求めたい配列はA(0-indexed)とする。",
            "BIT bit(N);",
            "int inv = 0;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    inv += i - bit.sum(A[i] + 1);",
            "    bit.add(A[i] + 1, 1);",
            "}",
            "// O(N^2)の求め方",
            "// int inv = 0;",
            "// for (int i = 0; i < N; i++)",
            "//     for (int j = 0; j < N; j++)",
            "//         if (i < j && A[i] > A[j])",
            "//             inv++;",
        ],
        "description": "inversion num for 1d vec"
    },
    "[Frame] loop 1d": {
        "prefix": "loop_1d",
        "body": [
            "for (int i = 0; i < N; i++)",
            "{",
            "    // logic",
            "}",
        ],
        "description": "1d loop"
    },
    "[Frame] loop 2d": {
        "prefix": "loop_2d",
        "body": [
            "for (int i = 0; i < N; i++)",
            "{",
            "    for (int j = 0; j < M; j++)",
            "    {",
            "        // logic",
            "    }",
            "}"
        ],
        "description": "loop 2d"
    },
    "[Frame] loop 3d": {
        "prefix": "loop_3d",
        "body": [
            "for (int i = 0; i < N; i++)",
            "{",
            "    for (int j = 0; j < M; j++)",
            "    {",
            "        for (int k = 0; k < L; k++)",
            "        {",
            "            // logic",
            "        }",
            "    }",
            "}"
        ],
        "description": "loop 3d"
    },
    "[Frame] loop map<int, int>": {
        "prefix": "loop_map",
        "body": [
            "map<int, int> mp;",
            "for (auto &[key, val] : mp)",
            "{",
            "    // logic",
            "}",
        ],
        "description": "loop map"
    },
    "[Frame] loop 1d Permutation": {
        "prefix": "loop_permitation_1d",
        "body": [
            "vector<int> P;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    P.emplace_back(i);",
            "}",
            "do",
            "{",
            "    for (int i = 0; i < N; i++)"
            "    {",
            "        // logic",
            "        // int p = P[i];",
            "    }",
            "} while (next_permutation(begin(P), end(P)));"
        ],
        "description": "loop 1d next_permutation"
    },
    "[Frame] loop bit full search": {
        "prefix": "loop_bit",
        "body": [
            "for (int bit = 0; bit < (1 << Nbit); bit++)",
            "{",
            "    vector<int> S;",
            "    for (int i = 0; i < Nbit; i++)",
            "    {",
            "        if (bit & (1 << i))",
            "        { // 列挙に i が含まれるか",
            "            S.emplace_back(i);",
            "        }",
            "    }",
            "    cout << bit << \": {\";",
            "    for (int i = 0; i < (int)S.size(); i++)",
            "    {",
            "        cout << S[i] << \" \";",
            "    }",
            "    cout << \"}\" << endl;",
            "}",
        ],
        "description": "loop bit full search"
    },
    "[Algorithm] game dfs": {
        "prefix": "gamedfs",
        "body": [
            "// Return score of the best move in the given state",
            "int dfs(State state) {",
            "    // use memo",
            "",
            "    // terminal condition",
            "    if (state is end) return score_in_end;",
            "",
            "    // try all moves",
            "    int res = -INF;",
            "    for (s  : all_state_reached_from_given_state) {",
            "        // dfs(s) return a score from opponent's view",
            "        // update res using sum & dfs(s)",
            "        res = max(res, sum - dfs(s));",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "game algo"
    },
    "[Class] BIT": {
        "prefix": "BIT",
        "body": [
            "// 1-indexed"
            "class BIT",
            "{",
            "public:",
            "    BIT(int _size) : size(_size), bit()",
            "    {",
            "        bit.resize(_size + 1);",
            "    }",
            "",
            "    // sum from 1 to idx",
            "    int sum(int idx)",
            "    {",
            "        int rtn = 0;",
            "        for (int i = idx; i > 0; i -= i & -i)",
            "        {",
            "            rtn += bit[i];",
            "        }",
            "        return rtn;",
            "    }",
            "",
            "    void add(int idx, int num)",
            "    {",
            "        for (int i = idx; i <= size; i += i & -i)",
            "        {",
            "            bit[i] += num;",
            "        }",
            "    }",
            "",
            "private:",
            "    const int size;",
            "    vector<int> bit;",
            "};",
        ],
    },
    "[Data] Binominal": {
        "prefix": "Binominal",
        "body": [
            "struct Binomial",
            "{",
            "    vector<mint> fac, invfac, inv;",
            "    Binomial(int n) : fac(n + 1), invfac(n + 1), inv(n + 1)",
            "    {",
            "        fac[0] = invfac[0] = inv[0] = 1;",
            "        for (int i = 1; i <= n; i++)",
            "            fac[i] = fac[i - 1] * i;",
            "        invfac[n] = fac[n].inv();",
            "        for (int i = n - 1; i >= 0; i--)",
            "        {",
            "            invfac[i] = invfac[i + 1] * (i + 1);",
            "            inv[i + 1] = invfac[i + 1] * fac[i];",
            "        }",
            "    }",
            "} C{303030};",
        ]
    },
}
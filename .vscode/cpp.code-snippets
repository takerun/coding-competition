{
    "[Initialization] G++ Code": {
        "prefix": "g++",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fastIO() ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)",
            "#define endl \"\\n\"",
            "#define all(x) std::begin(x), std::end(x)",
            "typedef long long int int64;",
            "",
            "int main()",
            "{",
            "    fastIO();",
            "    // input",
            "",
            "    // logic",
            "",
            "    // output",
            "    cout << endl;",
            "    return 0;",
            "}"
        ],
        "description": "G++ Code Setup"
    },
    "[Include] modint998244353": {
        "prefix": "include_modint998244353",
        "body": [
            "#include<atcoder/modint>",
            "using mint=atcoder::modint998244353;"
        ],
        "description": "include modint998244353"
    },
    "[Include] modint1000000007": {
        "prefix": "include_modint1000000007",
        "body": [
            "#include<atcoder/modint>",
            "using mint=atcoder::modint1000000007;"
        ],
        "description": "include modint1000000007"
    },
    "[Def] vector1": {
        "prefix": "def_vector1d",
        "body": "vector<int> x(n);",
        "description": "define 1D vector"
    },
    "[Def] vector2": {
        "prefix": "def_vector2d",
        "body": "vector<vector<int>> X(n, vector<int>(n));",
        "description": "define 2D vector"
    },
    "[Input] 1D": {
        "prefix": "input_1d",
        "body": [
            "for (int i = 0; i < N; i++)",
            "{",
            "    cin >> x[i];",
            "}",
        ],
        "description": "1D input"
    },
    "[Input] 2D": {
        "prefix": "input_2d",
        "body": [
            "for (int i = 0; i < H; i++)",
            "{",
            "    for (int j = 0; j < W; j++)",
            "    {",
            "        cin >> G.at(i).at(j);",
            "    }",
            "}"
        ],
        "description": "2D input"
    },
    "[Input] 1D Cumulative": {
        "prefix": "input_cumul1d",
        "body": [
            "int N;",
            "cin >> N;",
            "vector<int> x(N), cuml(N+1);",
            "cuml[0] = 0;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    cin >> x[i];",
            "    cuml[i + 1] = cuml[i] + x[i];",
            "}"
        ],
        "description": "1d cumulative input"
    },
    "[Input] each string": {
        "prefix": "input_string_with_intarr",
        "body": [
            "string astr;",
            "vector<int> a;",
            "int Asize;",
            "cin >> astr;",
            "Asize = astr.size();",
            "for (int i = 0; i < Asize; i++)",
            "{",
            "    a.emplace_back(astr[i] - '0');",
            "}",
        ],
        "description": "each sting input"
    },
    "[Measure] manhattan distance": {
        "prefix": "mandistance",
        "body": [
            "int distance = 0;",
            "for (int i = 0; i < N; i++)",
            "{",
            "    distance += abs(x[i] - y[i]);",
            "}",
        ],
        "description": "manhattan distance"
    },
    "[Method] retrieving max in vector": {
        "prefix": "maxvec1d",
        "body": "*max_element(all(x))",
        "description": "max in vactor"
    },
    "[Method] retrieving sum in vector": {
        "prefix": "sumvec1d",
        "body": "accumulate(all(x), 0)",
        "description": "sum in vactor"
    },
    "[Method] retrieving sum in stack": {
        "prefix": "sumstack1d",
        "body": [
            "int sum = 0;",
            "while (!s.empty())",
            "{",
            "    sum = sum + s.top();",
            "    s.pop();",
            "}",
        ],
        "description": "sum in stack"
    },
    "[Algorithm] game dfs": {
        "prefix": "gamedfs",
        "body": [
            "// Return score of the best move in the given state",
            "int dfs(State state) {",
            "    // use memo",
            "",
            "    // terminal condition",
            "    if (state is end) return score_in_end;",
            "",
            "    // try all moves",
            "    int res = -INF;",
            "    for (s  : all_state_reached_from_given_state) {",
            "        // dfs(s) return a score from opponent's view",
            "        // update res using sum & dfs(s)",
            "        res = max(res, sum - dfs(s));",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "game algo"
    }
}
{
    "[Initialization] G++ Code": {
        "prefix": "g++",
        "body": [
            "// #pragma GCC optimize(\"unroll-loops\")",
            "// #pragma GCC optimize(\"O3\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define fastIO()                      \\",
            "    ios_base::sync_with_stdio(false); \\",
            "    cin.tie(nullptr);                 \\",
            "    cout.tie(nullptr)",
            "#define endl \"\\n\"",
            "typedef long long int int64;",
            "",
            "int main() {",
            "    fastIO();",
            "    // input",
            "",
            "    // logic",
            "",
            "    // output",
            "    cout << endl;",
            "    return 0;",
            "}",
        ],
        "description": "G++ Code Setup"
    },
    "[Include] modint998244353": {
        "prefix": "include_modint998244353",
        "body": [
            "#include <atcoder/modint>",
            "using mint = atcoder::modint998244353;"
        ],
        "description": "include modint998244353"
    },
    "[Include] modint1000000007": {
        "prefix": "include_modint1000000007",
        "body": [
            "#include <atcoder/modint>",
            "using mint = atcoder::modint1000000007;"
        ],
        "description": "include modint1000000007"
    },
    "[Include] dsu": {
        "prefix": "include_dsu",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/dsu.html",
            "#include <atcoder/dsu>",
            "using dsu = atcoder::dsu;"
        ],
        "description": "include dsu(Union-Find tree)"
    },
    "[Include] segtree": {
        "prefix": "include_segtree",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/segtree.html",
            "#include <atcoder/segtree>",
            "using S = int64;                        // モノイドの型",
            "S op(S a, S b) { return max(a, b); }  // 取得演算: a+b, a*b, max(a,b)",
            "S e() { return 0; }                   // 単位元: 0, 1, -INF",
            "using segtree = atcoder::segtree<S, op, e>;",
            "// 使い方",
            "// segtree seg(N);",
        ],
        "description": "include segtree"
    },
    "[Include] lazy segtree": {
        "prefix": "include_lazy_segtree",
        "body": [
            "// https://atcoder.github.io/ac-library/document_en/lazysegtree.html",
            "// https://betrue12.hateblo.jp/entry/2020/09/23/005940",
            "#include <atcoder/lazysegtree>",
            "// 区間加算、区間最大値",
            "using S = int64;                           // モノイドの型",
            "S op(S a, S b) { return max(a, b); }       // 取得演算: max(a,b), min(a,b)",
            "S e() { return INT_MIN; }                  // 単位元: -INF, INF",
            "using F = int64;                           // 操作の型",
            "S mapping(F f, S x) { return f + x; }      // 操作演算:",
            "F composition(F f, F g) { return f + g; }  // 写像の合成:",
            "F id() { return 0; }                       // 恒等写像:",
            "using lazy_segtree =",
            "    atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;",
            "// 使い方",
            "// lazy_segtree seg(N);",
            "// 区間加算、区間和取得",
            "// struct S {",
            "//     int64 value;",
            "//     int size;",
            "// };",
            "// using F = int64;",
            "// S op(S a, S b) { return {a.value + b.value, a.size + b.size}; }",
            "// S e() { return {0, 0}; }",
            "// S mapping(F f, S x) { return {x.value + f * x.size, x.size}; }",
            "// F composition(F f, F g) { return f + g; }",
            "// F id() { return 0; }",
            "// using lazy_segtree =",
            "//     atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;",
            "// 使い方",
            "// vector<S> v(N, {0, 1});",
            "// lazy_segtree seg(v);",
        ],
        "description": "include lazy segtree"
    },
    "[Def] 1d vector": {
        "prefix": "def_vector_1d",
        "body": "vector<int> A(N, 0);",
        "description": "define 1d vector"
    },
    "[Def] 2d vector": {
        "prefix": "def_vector_2d",
        "body": "vector<vector<int>> Mat(H, vector<int>(W, 0));",
        "description": "define 2d vector"
    },
    "[Def] Nd vector": {
        "prefix": "def_vector_Nd",
        "body": "vector State(I, vector(J, vector(K, vector(L, 0))));",
        "description": "define Nd vector with Template argument deduction"
    },
    "[Def] int int map": {
        "prefix": "def_map_1d",
        "body": "map<int, int> mp = {{1, 10}, {2, 20}};",
        "description": "int int map"
    },
    "[Def] int int pair": {
        "prefix": "def_pair",
        "body": "pair<int, int> pr = {1, 10};",
        "description": "int int pair"
    },
    "[Def] int priority_queue": {
        "prefix": "def_priority_queue",
        "body": [
            "priority_queue<int> q;  // max",
            "priority_queue<int, vector<int>, greater<int>> q;  // min",
        ],
        "description": "int int pair"
    },
    "[Def] deque": {
        "prefix": "def_deque",
        "body": "deque<int> dq;",
        "description": "int int deque"
    },
    "[Def] lambda function": {
        "prefix": "def_func",
        "body": [
            "auto func = [&](int a, int b) {",
            "    if(a <= b)",
            "        return b - a;",
            "    else",
            "        return a - b;",
            "};",
        ],
        "description": "lambda function"
    },
    "[Input] int": {
        "prefix": "cin_int",
        "body": [
            "int N;",
            "cin >> N;",
        ],
        "description": "int input"
    },
    "[Input] 1d vector": {
        "prefix": "cin_vector_1d",
        "body": [
            "vector<int> A(N, 0);",
            "for(int &a : A) cin >> a;",
        ],
        "description": "int input"
    },
    "[Input] string": {
        "prefix": "cin_string",
        "body": [
            "string S;",
            "cin >> S;",
        ],
        "description": "each sting input"
    },
    "[Convert] char to int": {
        "prefix": "char_to_int",
        "body": [
            "int num = int(S[i] - '0');"
        ],
    },
    "[Convert] split string": {
        "prefix": "split_string",
        "body": [
            "// Sに空白が含まれると正常に動かないので注意",
            "string S;",
            "const string sep = \".\";",
            "auto offset = string::size_type(0);",
            "while(1) {",
            "    auto pos = S.find(sep, offset);",
            "    if(pos == string::npos) {",
            "        cout << S.substr(offset) << endl;",
            "        break;",
            "    }",
            "    cout << S.substr(offset, pos - offset) << endl;",
            "    offset = pos + sep.size();",
            "}",
        ],
    },
    "[Measure] manhattan distance": {
        "prefix": "measure_manhattan_distance",
        "body": [
            "int distance = 0;",
            "for(int i = 0; i < N; i++) {",
            "    distance += abs(A[i] - B[i]);",
            "}",
        ],
        "description": "manhattan distance"
    },
    "[Method] remainder quotient": {
        "prefix": "remainder_quotient",
        "body": [
            "int r = (x % mod + mod) % mod;",
            "int q = (x - r) / mod;",
        ],
        "description": "c++の割り算は、余りが正でないため"
    },
    "[Method] compare 1d vector": {
        "prefix": "equal_vec_1d",
        "body": "equal(begin(A), end(A), begin(B), end(B));",
        "description": "compare 1d vactor"
    },
    "[Method] compare 2d vector": {
        "prefix": "equal_vec_2d",
        "body": [
            "bool ans = true;",
            "for(int i = 0; i < N; i++) {",
            "    ans &= equal(begin(A), end(A), begin(B), end(B));",
            "}",
        ],
        "description": "compare 2d vactor"
    },
    "[Method] retrieving index in 1d vector":{
        "prefix": "find_vec_1d",
        "body": "int id = find(begin(A), end(A), key) - begin(A);",
        "description": "index in 1d vector",
    },
    "[Method] retrieving max general": {
        "prefix": "max_general",
        "body": [
            "int mx = INT_MIN;  // -2e9",
            "for(int i = 0; i < N; i++) {",
            "    mx = max(mx, A[i]);",
            "}",
        ],
        "description": "max general"
    },
    "[Method] retrieving max in 1d vector": {
        "prefix": "max_vec_1d",
        "body": "*max_element(begin(A), end(A))",
        "description": "max in 1d vactor"
    },
    "[Method] retrieving max in 2d vector": {
        "prefix": "max_vec_2d",
        "body": [
            "# 一番長い配列の配列数を返す",
            "ranges::max(vec_2d | views::transform([](auto &&v){ return size(v); }))",
        ],
        "description": "max in 2d vactor"
    },
    "[Method] retrieving max in map": {
        "prefix": "max_map",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // valueが同値なら、keyの小さい要素を取得",
            "    if(left.second == right.second)",
            "        return left.first > right.first;",
            "    else  // valueが大きい要素を取得",
            "        return left.second < right.second;",
            "};",
            "auto pr = *max_element(begin(mp), end(mp), order);",
            "// pr.first; pr.second;",
        ],
        "description": "max in map"
    },
    "[Method] retrieving min general": {
        "prefix": "min_general",
        "body": [
            "int mn = INT_MAX;  // 2e9",
            "for(int i = 0; i < N; i++) {",
            "    mn = min(mn, A[i]);",
            "}",
        ],
        "description": "min general"
    },
    "[Method] retrieving min in 1d vector": {
        "prefix": "min_vec_1d",
        "body": "*min_element(begin(A), end(A))",
        "description": "min in 1d vactor"
    },
    "[Method] retrieving min in map": {
        "prefix": "min_map",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // valueが同値なら、keyの小さい要素を取得",
            "    if(left.second == right.second)",
            "        return left.first < right.first;",
            "    else  // valueが小さい要素を取得",
            "        return left.second < right.second;",
            "};",
            "auto pr = *min_element(begin(mp), end(mp), order);",
            "// pr.first; pr.second;",
        ],
        "description": "min in map"
    },
    "[Method] retrieving sum in 1d vector": {
        "prefix": "sum_vec_1d",
        "body": "accumulate(begin(A), end(A), 0)",
        "description": "sum in 1d vactor"
    },
    "[Method] retrieving sum in stack": {
        "prefix": "sum_stack_1d",
        "body": [
            "int sum = 0;",
            "while(!stk.empty()) {",
            "    sum = sum + stk.top();",
            "    stk.pop();",
            "}",
        ],
        "description": "sum in 1d stack"
    },
    "[Method] retrieving cumulative in 1d vector": {
        "prefix": "cumul_vec_1d",
        "body": [
            "vector<int> A(N), cuml(N+1, 0);",
            "for(int i = 0; i < N; i++) {",
            "    cuml[i + 1] = cuml[i] + A[i];",
            "}"
        ],
        "description": "1d cumulative"
    },
    "[Method] counter in 1d vector": {
        "prefix": "counter_vec_1d",
        "body": [
            "vector<int> A;",
            "map<int, int> cntr;",
            "for(int i = 0; i < N; i++) {",
            "    cntr[A[i]]++;",
            "}",
        ],
        "description": "1d counter"
    },    
    "[Method] sort 1d vector ascending": {
        "prefix": "sort_vec_1d_ascending",
        "body": [
            "sort(begin(A), end(A));"
        ],
        "description": "sort for 1d vec"
    },
    "[Method] sort 1d vector descending": {
        "prefix": "sort_vec_1d_descending",
        "body": [
            "sort(begin(A), end(A), greater<int>());"
        ],
        "description": "sort for 1d vec"
    },
    "[Method] sort 1d pair flexible order": {
        "prefix": "sort_pair_1d",
        "body": [
            "auto order = [](const auto &left, const auto &right) {",
            "    // 第一要素が同値なら、第二要素で降順",
            "    if(left.first == right.first)",
            "        return left.second > right.second;",
            "    else  // 第一要素で昇順",
            "        return left.first < right.first;",
            "};",
            "sort(begin(A), end(A), order);",
        ],
        "description": "sort for 1d pair"
    },
    "[Method] not being duplicate in 1d vector": {
        "prefix": "no_duplicate_vec_1d",
        "body": [
            "sort(begin(A), end(A));",
            "A.erase(unique(begin(A), end(A)), end(A));",
        ],
        "description": "no duplicate for 1d vec"
    },
    "[Method] retrieving index at the bound greater than": {
        "prefix": "upper_bound_index",
        "body": [
            "upper_bound(begin(A), end(A), key) - begin(A)",
        ],
        "description": "index at the bound greater than"
    }, 
    "[Method] retrieving index at the bound greater than or equal": {
        "prefix": "lower_bound_index",
        "body": [
            "lower_bound(begin(A), end(A), key) - begin(A);",
        ],
        "description": "index at the bound greater than or equal"
    }, 
    "[Method] retrieving index at the bound greater than for pair": {
        "prefix": "upper_bound_index_pair",
        "body": [
            "vector<pair<int, int>> A;",
            "auto first_less = [](const auto &pr, const auto &mid) {",
            "    return pr.first < mid;",
            "};",
            "upper_bound(begin(A), end(A), key, first_less) - begin(A)",
        ],
        "description": "index at the bound greater than for pair"
    }, 
    "[Method] retrieving index at the bound greater than or equal for pair": {
        "prefix": "lower_bound_index_pair",
        "body": [
            "vector<pair<int, int>> A;",
            "auto first_less = [](const auto &pr, const auto &mid) {",
            "    return pr.first < mid;",
            "};",
            "lower_bound(begin(A), end(A), key, first_less) - begin(A);",
        ],
        "description": "index at the bound greater than or equal for pair"
    }, 
    "[Method] inversion num for 1d vector": {
        "prefix": "inversion_vec_1d",
        "body": [
            "// 転倒数を求めたい配列はA(0-indexed)とする。",
            "BIT bit(N);",
            "int inv = 0;",
            "for(int i = 0; i < N; i++) {",
            "    inv += i - bit.sum(A[i] + 1);",
            "    bit.add(A[i] + 1, 1);",
            "}",
            "// O(N^2)の求め方",
            "// int inv = 0;",
            "// for(int i = 0; i < N; i++)",
            "//     for(int j = 0; j < N; j++)",
            "//         if(i < j && A[i] > A[j]) inv++;",
        ],
        "description": "inversion num for 1d vec"
    },
    "[Method] regular expression": {
        "prefix": "regex",
        "body": [
            "if(regex_match(S, regex(\"A*B*C*\"))) {",
            "    cout << \"Yes\" << endl;",
            "} else {",
            "    cout << \"No\" << endl;",
            "}",
        ],
    },
    "[Frame] loop 1d": {
        "prefix": "loop_1d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    // logic",
            "}",
        ],
        "description": "1d loop"
    },
    "[Frame] loop 2d": {
        "prefix": "loop_2d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < M; j++) {",
            "        // logic",
            "    }",
            "}"
        ],
        "description": "loop 2d"
    },
    "[Frame] loop 3d": {
        "prefix": "loop_3d",
        "body": [
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < M; j++) {",
            "        for(int k = 0; k < L; k++) {",
            "            // logic",
            "        }",
            "    }",
            "}"
        ],
        "description": "loop 3d"
    },
    "[Frame] loop set": {
        "prefix": "loop_set",
        "body": [
            "set<int> st;",
            "for(const auto &s : st) {",
            "    // logic",
            "}",
        ],
        "description": "loop map"
    },
    "[Frame] loop map<int, int>": {
        "prefix": "loop_map",
        "body": [
            "map<int, int> mp;",
            "for(const auto &[key, val] : mp) {",
            "    // logic",
            "}",
        ],
        "description": "loop map"
    },
    "[Frame] loop 1d Permutation": {
        "prefix": "loop_permitation_1d",
        "body": [
            "vector<int> P;",
            "for(int i = 0; i < N; i++) {",
            "    P.emplace_back(i);",
            "}",
            "do {",
            "    for(int i = 0; i < N; i++) {",
            "        // logic",
            "        // int p = P[i];",
            "    }",
            "} while(next_permutation(begin(P), end(P)));"
        ],
        "description": "loop 1d next_permutation"
    },
    "[Frame] loop 1d Combination no duplicate": {
        "prefix": "loop_combination_no_duplicate",
        "body": [
            "// N種類のものから重複を許さず3個選ぶ",
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < i; j++) {",
            "        for(int k = 0; k < j; k++) {",
            "            cout << i << \" \" << j << \" \" << k << endl;",
            "        }",
            "    }",
            "}",
            "// for(int i = 0; i < N; i++) {",
            "//     for(int j = i + 1; j < N; j++) {",
            "//         for(int k = j + 1; k < N; k++) {",
            "//             cout << i << \" \" << j << \" \" << k << endl;",
            "//         }",
            "//     }",
            "// }",
        ],
        "description": "loop no duplicate combination"
    },
    "[Frame] loop 1d Combination duplicate": {
        "prefix": "loop_combination_duplicate",
        "body": [
            "// N種類のものから重複を許して3個選ぶ",
            "for(int i = 0; i < N; i++) {",
            "    for(int j = 0; j < i + 1; j++) {",
            "        for(int k = 0; k < j + 1; k++) {",
            "            cout << i << \" \" << j << \" \" << k << endl;",
            "        }",
            "    }",
            "}",
            "// for(int i = 0; i < N; i++) {",
            "//     for(int j = i; j < N; j++) {",
            "//         for(int k = j; k < N; k++) {",
            "//             cout << i << \" \" << j << \" \" << k << endl;",
            "//         }",
            "//     }",
            "// }",
        ],
        "description": "loop duplicate combination"
    },
    "[Frame] loop bit full search": {
        "prefix": "loop_bit",
        "body": [
            "int Nbit = 5;",
            "// 3進数全探索の場合、int(pow(3,Nbit))に変換",
            "for(int i = 0; i < (1 << Nbit); i++) {",
            "    vector<int> bit(Nbit);",
            "    int pow = 1;"
            "    for(int j = 0; j < Nbit; j++) {",
            "        bit[j] = (i / pow) % 2;  // 3進数全探索の場合、(i/pow)%3に変換",
            "        pow <<= 1;               // 3進数全探索の場合、pow*=3に変換",
            "    }",
            "    // logic",
            "    cout << i << \": {\";",
            "    for(int j = 0; j < Nbit; j++) {",
            "        cout << bit[j] << \" \";",
            "    }",
            "    cout << \"}\" << endl;",
            "}",
        ],
        "description": "loop bit full search"
    },
    "[Algorithm] binary search": {
        "prefix": "binary_search",
        "body":[
            "auto f = [&](int64 x) { return x * x; };  // 単調非減少な関数f",
            "int64 l = 0, r = 2e18;",
            "while((l + 1) < r) {",
            "    int64 mid = (l + r) / 2;",
            "    if(f(mid) < K)  // upper_boundの場合、f(mid)<=K",
            "        l = mid;",
            "    else",
            "        r = mid;",
            "}",
        ],
        "description": "binary search for a function",
    },
    "[Algorithm] dfs": {
        "prefix": "dfs",
        "body": [
            "map<int, int> m;",
            "int dfs(int x) {",
            "    // exit conditions",
            "    if(x == 1) return 0;",
            "",
            "    // shotcut conditions",
            "",
            "    // use memo",
            "    if(m.count(x)) return m[x];",
            "",
            "    // try all moves",
            "    // pattern1:",
            "    // return m[x] = dfs(x1) + dfs(x2) + x;",
            "    // pattern2:",
            "    // for(int v = 0; v < N; v++) {",
            "    //     Stat.push_back(v);",
            "    //     dfs(Stat);",
            "    //     Stat.pop_back();",
            "    // }",
            "    // pattern3:",
            "    // if(dfs(x1)) return true;",
            "    // if(dfs(x2)) return true;",
            "    // return false",
            "}",
        ],
        "description": "dfs",
    },
    "[Algorithm] bfs": {
        "prefix": "bfs",
        "body": [
            "// define Value & State of 2d",
            "vector<vector<int>> Val(H, vector<int>(W, 0));",
            "vector<int> initS = {0, 0};",
            "Val[initS[0]][initS[1]] = 0;",
            "// define queue",
            "queue<vector<int>> Q;",
            "Q.push(initS);",
            "while(!Q.empty()) {",
            "    // pop queue",
            "    vector<int> q = Q.front();",
            "    Q.pop();",
            "",
            "    // evaluate state",
            "    if(q == {1, 1}) {",
            "        // push state",
            "        Q.push({0, 0});",
            "    }",
            "}",
        ],
        "description": "bfs",
    },
    "[Algorithm] game dfs": {
        "prefix": "gamedfs",
        "body": [
            "// Return score of the best move in the given state",
            "int dfs(State state) {",
            "    // use memo",
            "",
            "    // terminal condition",
            "    if(state is end) return score_in_end;",
            "",
            "    // try all moves",
            "    int res = -INF;",
            "    for(s  : all_state_reached_from_given_state) {",
            "        // dfs(s) return a score from opponent's view",
            "        // update res using sum & dfs(s)",
            "        res = max(res, sum - dfs(s));",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "game algo"
    },
    "[Algorithm] imos":{
        "prefix": "imos",
        "body": [
            "// count",
            "vector<int64> imos(T + 1, 0);",
            "for(int i = 0; i < N; i++) {",
            "    imos[from] += num;",
            "    imos[to] -= num;",
            "}",
            "// simulate",
            "int64 cuml = imos[0];",
            "int64 mn = cuml;",
            "for(int i = 1; i < T; i++) {",
            "    // i=Tまで累積和を計算すると、注目する期間に加え1秒後の状態0を含む期間となる",
            "    // 1秒後の状態0は大概不要",
            "    cuml += imos[i];",
            "    mn = min(mn, cuml);",
            "}",
            "cout << mn;",
        ],
        "description": "imos",
    },
    "[Algorithm] Dijkstra":{
        "prefix": "dijkstra",
        "body": [
            "constexpr int64 INF = (1LL << 60);",
            "struct Edge {",
            "    int to;",
            "    int64 cost;",
            "};",
            "using Graph = vector<vector<Edge>>;",
            "using Pair = pair<int64, int>;  // {distance, from}",
            "",
            "// ダイクストラ法:",
            "// 負の閉路がなければ実行可能",
            "// distances は頂点数と同じサイズ, 全要素 INF で初期化しておく",
            "// Graph G(V);",
            "//   G[from].emplace_back({to, cost});",
            "// vector<int64> d(V, INF);",
            "// Dijkstra(G, d, 0);",
            "// cout << d[V - 1];",
            "void Dijkstra(const Graph& graph, vector<int64>& distances,",
            "              int startIndex) {",
            "    // 「現時点での最短距離, 頂点」の順に取り出す priority_queue",
            "    // デフォルトの priority_queue は降順に取り出すため greater を使う",
            "    priority_queue<Pair, vector<Pair>, greater<Pair>> q;",
            "    q.emplace((distances[startIndex] = 0), startIndex);",
            "",
            "    while(!q.empty()) {",
            "        const int64 distance = q.top().first;",
            "        const int from = q.top().second;",
            "        q.pop();",
            "",
            "        // 最短距離でなければ処理しない",
            "        if(distances[from] < distance) {",
            "            continue;",
            "        }",
            "",
            "        // 現在の頂点からの各辺について",
            "        for(const auto& edge : graph[from]) {",
            "            // 連結がなければスキップする",
            "",
            "            // to までの新しい距離",
            "            const int64 d = (distances[from] + edge.cost);",
            "",
            "            // d が現在の記録より小さければ更新",
            "            if(d < distances[edge.to]) {",
            "                q.emplace((distances[edge.to] = d), edge.to);",
            "            }",
            "        }",
            "    }",
            "}",
        ],
        "description": "dijkstra",
    },
    "[Class] BIT": {
        "prefix": "BIT",
        "body": [
            "// 1-indexed",
            "class BIT {",
            "  public:",
            "    BIT(int _size) : size(_size), bit() { bit.resize(_size + 1); }",
            "",
            "    // sum from 1 to idx",
            "    int sum(int idx) {",
            "        int rtn = 0;",
            "        for(int i = idx; i > 0; i -= i & -i) {",
            "            rtn += bit[i];",
            "        }",
            "        return rtn;",
            "    }",
            "",
            "    void add(int idx, int num) {",
            "        for(int i = idx; i <= size; i += i & -i) {",
            "            bit[i] += num;",
            "        }",
            "    }",
            "",
            "  private:",
            "    const int size;",
            "    vector<int> bit;",
            "};",
        ],
        "description": "Binary-Indexed tree(Fenwick tree)",
    },
    "[Class] Combination": {
        "prefix": "Combination",
        "body": [
            "class Combination {",
            "  public:",
            "    Combination(int _n, int _r) : n(_n), r(_r), comb() { comb.resize(_r); }",
            "",
            "    void for_comb(std::function<void(vector<int>)> f) {",
            "        __for_comb(n, r, r, f);",
            "    }",
            "",
            "    void __for_comb(int size, int rest, int depth,",
            "                    std::function<void(vector<int>)> f) {",
            "        if(depth == 0) {",
            "            f(comb);",
            "            return;",
            "        }",
            "",
            "        for(int i = 0; i < size; i++) {",
            "            comb[rest - depth] = i;",
            "            __for_comb(i, rest, depth - 1, f);",
            "        }",
            "    }",
            "",
            "  private:",
            "    const int n, r;",
            "    vector<int> comb;",
            "};",
            "// 使い方",
            "// Combination comb(10, 3);",
            "// comb.for_comb([](const auto &cmb) {",
            "//     cout << cmb[0] << cmb[1] << cmb[2] << endl;",
            "// });",
        ]
    },
    "[Data] Binominal": {
        "prefix": "Binominal",
        "body": [
            "struct Binomial {",
            "    vector<mint> fac, invfac, inv;",
            "    Binomial(int n) : fac(n + 1), invfac(n + 1), inv(n + 1) {",
            "        fac[0] = invfac[0] = inv[0] = 1;",
            "        for(int i = 1; i <= n; i++)",
            "            fac[i] = fac[i - 1] * i;",
            "        invfac[n] = fac[n].inv();",
            "        for(int i = n - 1; i >= 0; i--) {",
            "            invfac[i] = invfac[i + 1] * (i + 1);",
            "            inv[i + 1] = invfac[i + 1] * fac[i];",
            "        }",
            "    }",
            "} C{303030};",
        ]
    },
    "[Data] Direction 4": {
        "prefix": "data_direction_4",
        "body": [
            "int dc = 0;",
            "const string rotation = \"URDL\";",
            "map<char, const int> dh = {{'R', 0}, {'L', 0}, {'U', -1}, {'D', 1}},",
            "                     dw = {{'R', 1}, {'L', -1}, {'U', 0}, {'D', 0}};",
        ]
    },
}